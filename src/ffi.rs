//! Imports and exports to the Gotime runtime.

use alloc::sync::Arc;
use core::{mem::MaybeUninit, task::Context};

use crate::SharedTask;

/// Generated automatically by `bindgen` from the header generated by the Go compiler.
///
/// Kept as a private module so that this module's type-safe wrappers must be used to access it.
mod generated {
    #![allow(non_upper_case_globals)]
    #![allow(non_camel_case_types)]
    #![allow(non_snake_case)]

    include!(concat!(env!("OUT_DIR"), "/runtime.rs"));
}

#[export_name = "gotime_poll_task"]
pub unsafe extern "C" fn process_task(shared_task: *const SharedTask) -> core::ffi::c_char {
    // Arc::clone on a pointer
    let task = {
        Arc::increment_strong_count(shared_task);
        Arc::from_raw(shared_task)
    };
    let waker = crate::MyWaker::new(task.clone());
    let mut context = Context::from_waker(&waker);
    let is_done = task
        .fut
        .get()
        .as_mut()
        .unwrap()
        .as_mut()
        .poll(&mut context)
        .is_pending();
    if is_done {
        Arc::decrement_strong_count(shared_task);
    }
    is_done.into()
}

pub fn spawn_task(task: Arc<SharedTask>) -> GoHandle {
    GoHandle(unsafe { generated::gotime_spawn_task(Arc::into_raw(task).cast_mut().cast()) })
}

pub fn block_on(handle: &GoHandle) {
    unsafe { generated::gotime_block_on(handle.0) }
}

pub fn wake_task(handle: &GoHandle) {
    unsafe { generated::gotime_wake_task(handle.0) }
}

pub fn allocate<T>() -> (GoHandle, *mut MaybeUninit<T>) {
    let size = core::mem::size_of::<T>();
    let align = core::mem::size_of::<T>();

    let generated::gotime_allocate_return {
        r0: handle,
        r1: ptr,
    } = unsafe { generated::gotime_allocate(size, align) };

    let handle = GoHandle(handle);
    let ptr = ptr as *mut MaybeUninit<T>;

    if align > 0 {
        debug_assert_eq!(
            ptr as usize % align,
            0,
            "allocated pointer ({:p}) has incorrect alignment",
            ptr,
        );
    }

    (handle, ptr)
}

pub fn clone_allocation(handle: &GoHandle) -> GoHandle {
    GoHandle(unsafe { generated::gotime_clone_allocation(handle.0) })
}

pub fn free<T>(handle: GoHandle) {
    extern "C" fn drop_t<T2>(value: *mut T2) {
        unsafe {
            core::ptr::drop_in_place(value);
        }
    }
    let on_drop = drop_t::<T> as extern "C" fn(_);
    // I hate this transmute, but the compiler suggested it would be valid
    let on_drop = unsafe { core::mem::transmute(on_drop) };
    let on_drop: generated::drop_callback = Some(on_drop);
    unsafe { generated::gotime_free(handle.0, on_drop) }
}

#[derive(Debug, Hash, PartialEq, Eq)]
pub struct GoHandle(usize);

impl GoHandle {
    pub fn nil() -> Self {
        Self(0)
    }
}
