//! Imports and exports to the Gotime runtime.

use std::{sync::Arc, task::Context};

use crate::SharedTask;

/// Generated automatically by `bindgen` from the header generated by the Go compiler.
///
/// Kept as a private module so that this module's type-safe wrappers must be used to access it.
mod generated {
    #![allow(non_upper_case_globals)]
    #![allow(non_camel_case_types)]
    #![allow(non_snake_case)]

    include!(concat!(env!("OUT_DIR"), "/runtime.rs"));
}

#[export_name = "gotime_poll_task"]
pub unsafe extern "C" fn process_task(shared_task: *const SharedTask) -> std::ffi::c_char {
    // Arc::clone on a pointer
    let task = {
        Arc::increment_strong_count(shared_task);
        Arc::from_raw(shared_task)
    };
    let waker = crate::waker::new(task.clone());
    let mut context = Context::from_waker(&waker);
    let is_done = task
        .fut
        .lock()
        .unwrap()
        .as_mut()
        .poll(&mut context)
        .is_pending();
    if is_done {
        Arc::decrement_strong_count(shared_task);
    }
    is_done.into()
}

pub fn spawn_task(task: Arc<SharedTask>) -> GoHandle {
    GoHandle(unsafe { generated::gotime_spawn_task(Arc::into_raw(task).cast_mut().cast()) })
}

pub fn block_on(handle: GoHandle) {
    unsafe { generated::gotime_block_on(handle.0) }
}

pub fn wake_task(handle: GoHandle) {
    unsafe { generated::gotime_wake_task(handle.0) }
}

#[derive(Debug, Clone, Copy, Hash, PartialEq, Eq)]
pub struct GoHandle(usize);

impl GoHandle {
    pub fn nil() -> Self {
        Self(0)
    }
}
